{"./":{"url":"./","title":"介绍","keywords":"","body":" 原文地址 https://zhuanlan.zhihu.com/p/117490792 前言 我曾经一度很迷茫，在学了 Vue、React 的实战开发和应用以后，好像遇到了一些瓶颈，不知道该怎样继续深入下去。相信这也是很多一两年经验的前端工程师所遇到共同问题，这篇文章，笔者想结合自己的一些成长经历整理出一些路线，帮助各位初中级前端工程师少走一些弯路。 笔者毕业于一个很普通的本科学校，非计算机专业，17 年的时候刚毕业的时候还不知道自己的方向在哪（实习做过销售、运营、推广）。后来机缘巧合走上了开发这条路，第一年的时候 Java 和前端都做，慢慢发现了自己的兴趣所在转向前端。第二年的时候跳槽来到杭州，开始前端工程师的生涯。 目前开发经验一共是 2 年 8 个月，目前带一个 5 人的团队，前任的组长让我带领团队的主要原因是个人技术 + 沟通能力相对较好，但是在技术能力成长的背后需要怎么去走呢，相信有很多小伙伴会迷失方向。 这篇文章会提到非常非常多的学习路线和链接，如果你还在初中级的阶段，不必太焦虑，可以把这篇文章作为一个进阶的路线图，在未来的时日里朝着这个方向努力就好。我也并不是说这篇文章是进阶高级工程师的唯一一条路线，如果你在业务上做的精进，亦或是能在沟通上八面玲珑，配合各方面力量把项目做的漂漂亮亮，那你也一样可以拥有这个头衔。本文只是我自己的一个成长路线总结。 本篇文章面对的人群是开发经验1到3年的初中级前端工程师，希望能和你们交个心。 已经晋升高级前端的同学，欢迎你在评论区留下你的心得，补充我的一些缺失和不足。 我的 github 地址，欢迎 follow，我会持续更新一些值得你关注的项目。 我的 blog 地址，这里会持续更新，点个 star 不失联！✨ 广告警告 在本文中，我会在一些路线中推荐一些我学习过后觉得很棒的掘金小册，会用到我自己的推荐码。如果你很介意这个，那只能说抱歉咱们不太有缘分，离开这个网页吧。我不觉得这有什么可耻的，我只会推确实在我学习路径上帮助到我的小册。（会涉及到设计模式、性能优化以及 TypeScript 小册推荐） 基础能力 我整理了一篇中级前端的必备技术栈能力，写给女朋友的中级前端面试秘籍 。这篇文章里的技术栈当然都是需要扎实掌握的，（其实我自己也有一些漏缺，偷偷补一下）。 当然了，上进心十足的你不会一直满足于做中级前端，我们要继续向上，升职加薪，迎娶白富美！ JavaScript 原生 js 系列 冴羽大佬的这篇博客里，除了 undescore 的部分，你需要全部都能掌握。并且灵活的运用到开发中去。JavaScript 深入系列、JavaScript 专题系列、ES6 系列 完全熟练掌握 eventLoop。 tasks-microtasks-queues-and-schedules Promise 你需要阅读 Promise A + 规范，注意其中的细节，并且灵活的运用到开发当中去。Promise A+ 英文文档 你需要跟着精品教程手写一遍 Promise，对里面的细节深入思考，并且把其中异步等待、错误处理等等细节融会贯通到你的开发思想里去。剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类 最后，对于 promise 的核心，异步的链式调用，你必须能写出来简化版的代码。最简实现 Promise，支持异步链式调用（20 行） 题外话，当时精炼这 20 行真的绕了我好久 ，但是搞明白了会有种恍然大悟的感觉。这种异步队列的技巧要融会贯通。 async await 对于 Promise 我们非常熟悉了，进一步延伸到 async await，这是目前开发中非常非常常用的异步处理方式，我们最好是熟悉它的 babel 编译后的源码。 手写 async await 的最简实现（20 行搞定）babel 对于 async await 配合 generator 函数，做的非常巧妙，这里面的思想我们也要去学习，如何递归的处理一个串行的 promise 链？ 这个技巧在 axios 的源码里也有应用。平常经常用的拦截器，本质上就是一串 promise 的串行执行。 当然，如果你还有余力的话，也可以继续深入的去看 generator 函数的 babel 编译源码。不强制要求，毕竟 generator 函数在开发中已经用的非常少了。ES6 系列之 Babel 将 Generator 编译成了什么样子 异常处理 你必须精通异步场景下的错误处理，这是高级工程师必备的技能，如果开发中的异常被你写的库给吞掉了，那岂不是可笑。Callback Promise Generator Async-Await 和异常处理的演进 插件机制 你需要大概理解前端各个库中的插件机制是如何实现的，在你自己开发一些库的时候也能融入自己适合的插件机制。Koa 的洋葱中间件，Redux 的中间件，Axios 的拦截器让你迷惑吗？实现一个精简版的就彻底搞懂了。 设计模式 对于一些复杂场景，你的开发不能再是if else嵌套一把梭了，你需要把设计模式好好看一遍，在合适的场景下选择合适的设计模式。这里就推荐掘金小册吧，相信这篇小册会让你的工程能力得到质的飞跃，举例来说，在 Vue 的源码中就用到了观察者模式、发布订阅模式、策略模式、适配器模式、发布订阅模式、工厂模式、组合模式、代理模式、门面模式等等。 而这些设计模式如果你没学习过可能很难想到如何应用在工程之中，但是如果你学习过，它就变成了你内在的工程能力，往大了说，也可以是架构能力的一部分。  在《设计模式》这本小册中我们提到过，即使是在瞬息万变的前端领域，也存在一些具备 “一次学习，终生受用” 特性的知识。从工程的角度看，我推荐大家着重学习的是设计模式。 - 修言” ![][img-0] 基础算法 掌握一些基础算法核心思想或简单算法问题，比如排序。 开发思想 你需要知道组合优于继承的思想，不要再满口都是 oop，写什么都来个 class extends 了，在前端 ui 扁平化的前提下，真的没那么多需要继承的场景。https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9  “…the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” ~ Joe Armstrong — “Coders at Work”” 面向对象语言的问题在于它们带来了所有这些隐含的环境。 你想要一个香蕉，但你得到的是拿着香蕉和整个丛林的大猩猩。” 代码规范 你需要熟读 clean-code-javascript，并且深入结合到日常开发中，结合你们小组的场景制定自己的规范。clean-code-javascript 框架篇 对于高级工程师来说，你必须要有一个你趁手的框架，它就像你手中的一把利剑，能够让你披荆斩棘，斩杀各种项目于马下。 下面我会分为Vue和React两个方面深入去讲。 Vue Vue 方面的话，我主要是师从黄轶老师，跟着他认真走，基本上在 Vue 这方面你可以做到基本无敌。 熟练运用 对于 Vue 你必须非常熟练的运用，官网的 api 你基本上要全部过一遍。并且你要利用一些高级的 api 去实现巧妙的封装。举几个简单的例子。 你要知道怎么用slot-scope去做一些数据和 ui 分离的封装。 以 vue-promised 这个库为例。 Promised 组件并不关注你的视图展示成什么样，它只是帮你管理异步流程，并且通过你传入的slot-scope，在合适的时机把数据回抛给你，并且帮你去展示你传入的视图。 Loading... {{ user.name }} Error: {{ error.message }} 你需要熟练的使用Vue.extends，配合项目做一些命令式api的封装。并且知道它为什么可以这样用。（需要具备源码知识） confirm 组件 export const confirm = function(text, title, onConfirm = () => {}) { if (typeof title === \"function\") { onConfirm = title title = undefined } const ConfirmCtor = Vue.extend(Confirm) const getInstance = () => { if (!instanceCache) { instanceCache = new ConfirmCtor({ propsData: { text, title, onConfirm } }) // 生成dom instanceCache.$mount() document.body.appendChild(instanceCache.$el) } else { // 更新属性 instanceCache.text = text instanceCache.title = title instanceCache.onConfirm = onConfirm } return instanceCache } const instance = getInstance() // 确保更新的prop渲染到dom // 确保动画效果 Vue.nextTick(() => { instance.visible = true }) } 你要开始使用JSX来编写你项目中的复杂组件了，比如在我的网易云音乐项目中，我遇到了一个复杂的音乐表格需求，支持搜索文字高亮、动态隐藏列等等。当然对于现在版本的 Vue，JSX 还是不太好用，有很多属性需要写嵌套对象，这会造成很多不必要的麻烦，比如没办法像 React 一样直接把外层组件传入的 props 透传下去，Vue3 的 rfc 中提到会把 vnode 节点的属性进一步扁平化，我们期待得到接近于 React 的完美 JSX 开发体验吧。 const tableAttrs = { attrs, on: { ...this.$listeners, [\"row-click\"]: this.onRowClick, }, props: { ...props, headerCellClassName: \"title-th\", cellClassName: this.tableCellClassName, data: this.songs, }, } 你要深入了解 Vue 中 nextTick 的原理，并且知道为什么要用微任务队列优于宏任务队列，结合你的 eventloop 知识深度思考。最后融入到你的异步合并优化的知识体系中去。Vue 源码详解之 nextTick：MutationObserver 只是浮云，microtask 才是核心！ 你要能理解 Vue 中的高阶组件。关于这篇文章中为什么 slot-scope 不生效的问题，你不能看他的文章讲解都一头雾水。（需要你具备源码知识）探索 Vue 高阶组件 | HcySunYang 对于 Vuex 和 vue-router 的使用必须非常熟练，知道什么时候该用 Vuex，什么需求需要利用什么样的 router 钩子，这样才能 hold 住一个大型的项目，这个我觉得还是尽量去学源码吧。 源码深入 你不光要熟练运用 Vue，由于 Vue 的源码写的非常精美，而且阅读难度不是非常大，很多人也选择去阅读 Vue 的源码。先推荐一个阿里巴巴的柒陌同学掘金的小册，9.9 元买不了吃亏，每章节还附带demo，非常适合入门源码： ![][img-1] 视频课这里推荐黄轶老师的 Vue 源码课程。这里也包括了 Vuex 和 vue-router 的源码。Vue.js 源码全方位深入解析 （含 Vue3.0 源码分析） 推荐 HcySunYang 大佬的 Vue 逐行分析，需要下载 git 仓库，切到 elegant 分支自己本地启动。Vue 逐行级别的源码分析 当然，这个仓库的 master 分支也是宝藏，是这个作者的渲染器系列文章，脱离框架讲解了 vnode 和 diff 算法的本质组件的本质 Vue3 展望 Vue3 已经发布了 Alpha 版本，你可以提前学习Hook相关的开发模式了，面向未来的异步请求管理是 zeit/swr 这种自定义 Hook 库所带来的。 在讲解之前，先举个例子，在 Vue2 中如果我需要请求一份数据，并且在loading和error时都展示对应的视图，一般来说，我们会这样写： failed to load loading... hello {{fullName}}! import { createComponent, computed } from 'vue' import useSWR from 'vue-swr' export default { data() { // 集中式的data定义 如果有其他逻辑相关的数据就很容易混乱 return { data: { firstName: '', lastName: '' }, loading: false, error: false, }, }, async created() { try { // 管理loading this.loading = true // 取数据 const data = await this.$axios('/api/user') this.data = data } catch (e) { // 管理error this.error = true } finally { // 管理loading this.loading = false } }, computed() { // 没人知道这个fullName和哪一部分的异步请求有关 和哪一部分的data有关 除非仔细阅读 // 在组件大了以后更是如此 fullName() { return this.data.firstName + this.data.lastName } } } 这段代码，怎么样都谈不上优雅，凑合的把功能完成而已，并且对于loading、error等处理的可复用性为零。 数据和逻辑也被分散在了各个option中，这还只是一个逻辑，如果又多了一些逻辑，多了data、computed、methods？如果你是一个新接手这个文件的人，你如何迅速的分辨清楚这个method是和某两个data中的字段关联起来的？ 让我们把 zeit/swr 的逻辑照搬到 Vue3 中， 看一下swr在 Vue3 中的表现： failed to load loading... hello {{fullName}}! import { createComponent, computed } from 'vue' import useSWR from 'vue-swr' export default createComponent({ setup() { // useSWR帮你管理好了取数、缓存、甚至标签页聚焦重新请求、甚至Suspense... const { data, loading, error } = useSWR('/api/user', fetcher) // 轻松的定义计算属性 const fullName = computed(() => data.firstName + data.lastName) return { data, fullName, loading, error } } }) 就是这么简单，对吗？逻辑更加聚合了。 有人要问，全部逻辑都写在 setup 里了，这是面条式代码！而且针对我上面提出的代码逻辑分散的问题，哪里进步了。 那么我们用自定义hook把逻辑统一抽出来？ failed to load loading... hello {{fullName}}! import { createComponent, computed } from 'vue' import useSWR from 'vue-swr' export default createComponent({ setup() { return { ...useName() } } }) // 姓名相关逻辑 function useName() { // useSWR帮你管理好了取数、缓存、甚至标签页聚焦重新请求、甚至Suspense... const { data, loading, error } = useSWR('/api/user', fetcher) // 轻松的定义计算属性 const fullName = computed(() => data.firstName + data.lastName) return { data, fullName, loading, error } } 这下好了，useName这个 hook 甚至成为了一个所有组件都可以共用的 hook。在 Vue2 里，你怎么抽取？难道用mixins？ 那么你应该看这篇知乎：为何不要用 mixins 来实现组件复用 Vue3 源码 对于响应式部分，如果你已经非常熟悉 Vue2 的响应式原理了，那么 Vue3 的响应式原理对你来说应该没有太大的难度。甚至在学习之中你会相互比较，知道 Vue3 为什么这样做更好，Vue2 还有哪部分需要改进等等。 Vue3 其实就是把实现换成了更加强大的 Proxy，并且把响应式部分做的更加的抽象，甚至可以，不得不说，Vue3 的响应式模型更加接近响应式类库的核心了，甚至react-easy-state等 React 的响应式状态管理库，也是用这套类似的核心做出来的。 再次强调，非常非常推荐学习 Vue3 的@vue/reactivity这个分包。 推一波自己的文章吧，细致了讲解了 Vue3 响应式的核心流程。 带你彻底搞懂 Vue3 的 Proxy 响应式原理！TypeScript 从零实现基于 Proxy 的响应式库。 带你彻底搞懂 Vue3 的 Proxy 响应式原理！基于函数劫持实现 Map 和 Set 的响应式 深度解析：Vue3 如何巧妙的实现强大的 computed 在学习之后，我把@vue/reactivity包轻松的集成到了 React 中，做了一个状态管理的库，这也另一方面佐证了这个包的抽象程度：40 行代码把 Vue3 的响应式集成进 React 做状态管理 React React 已经进入了 Hook 为主的阶段，社区的各个库也都在积极拥抱 Hook，虽然它还有很多陷阱和不足，但是这基本上是未来的方向没跑了。这篇文章里我会减少 class 组件的开发技巧的提及，毕竟好多不错的公司也已经全面拥抱 Hook 了。 熟练应用 你必须掌握官网中提到的所有技巧，就算没有使用过，你也要大概知道该在什么场景使用。 推荐 React 小书，虽然书中的很多 api 已经更新了，但是核心的设计思想还是没有变React.js 小书 关于熟练应用，其实掘金的小册里有几个宝藏 诚身大佬（悄悄告诉你，他的职级非常高）的企业级管理系统小册，这个项目里的代码非常深入，而且在抽象和优化方面也做的无可挑剔，自己抽象了acl权限管理系统和router路由管理，并且引入了reselect做性能优化，一年前我初次读的时候，很多地方懵懵懂懂，这一年下来我也从无到有经手了一套带acl和权限路由的管理系统后，才知道他的抽象能力有多强。真的是 初闻不知曲中意，再闻已是曲中人。”React 组合式开发实践：打造企业管理系统五大核心模块 三元大佬的 React Hooks 与 Immutable 数据流实战，深入浅出的带你实现一个音乐播放器。三元大家都认识吧？那是神，神带你们写应用项目，不学能说得过去吗？ React Hooks 与 Immutable 数据流实战 深入理解 React 中的keyunderstanding-reacts-key-propreact 中为何推荐设置 key React 官方团队成员对于派生状态的思考：you-probably-dont-need-derived-state React Hook 你必须熟练掌握 Hook 的技巧，除了官网文档熟读以外： 推荐 Dan 的博客，他就是 Hook 的代码实际编写者之一，看他怎么说够权威了吧？这里贴心的送上汉化版。useEffect 完整指南看完这篇以后，进入 dan 的博客主页，找出所有和 Hook 有关的，全部精读！ 推荐黄子毅大佬的精读周刊系列096. 精读《useEffect 完全指南》.md注意！不是只看这一篇，而是这个仓库里所有有关于 React Hook 的文章都去看一遍，结合自己的思想分析。 Hook 陷阱系列 还是 Dan 老哥的文章，详细的讲清楚了所谓闭包陷阱产生的原因和设计中的权衡。函数式组件与类组件有何不同？ 去找一些社区的精品自定义 hook，看看他们的开发和设计思路，有没有能融入自己的日常开发中去的。精读《Hooks 取数 - swr 源码》Umi Hooks - 助力拥抱 React HooksReact Hooks 的体系设计之一 - 分层 React 性能优化 React 中优化组件重渲染，这里有几个隐含的知识点。optimize-react-re-renders 如何对 React 函数式组件进行性能优化？这篇文章讲的很详细，值得仔细阅读一遍。 https://juejin.im/post/5dd337985188252a1873730f React 单元测试 使用@testing-library/react测试组件，这个库相比起 enzyme 更好的原因在于，它更注重于站在用户的角度去测试一个组件，而不是测试这个组件的实现细节。Introducing The React Testing LibraryTesting Implementation Details 使用@testing-library/react-hooks测试自定义 Hookhow-to-test-custom-react-hooks React 和 TypeScript 结合使用 这个仓库非常详细的介绍了如何把 React 和 TypeScript 结合，并且给出了一些进阶用法的示例，非常值得过一遍！react-typescript-cheatsheet 这篇文章是蚂蚁金服数据体验技术部的同学带来的，其实除了这里面的技术文章以外，蚂蚁金服的同学也由非常生动给我们讲解了一个高级前端同学是如何去社区寻找方案，如何思考和落地到项目中的，由衷的佩服。React + Typescript 工程化治理实践 微软的大佬带你写一个类型安全的组件，非常深入，非常过瘾...Writing Type-Safe Polymorphic React Components (Without Crashing TypeScript) React + TypeScript 10 个需要避免的错误模式。10-typescript-pro-tips-patterns-with-or-without-react React 代码抽象思考 何时应该把代码拆分为组件？when-to-break-up-a-component-into-multiple-components 仔细思考你的 React 应用中，状态应该放在什么位置，是组件自身，提升到父组件，亦或是局部 context 和 redux，这会有益于提升应用的性能和可维护性。state-colocation-will-make-your-react-app-faster 仔细思考 React 组件中的状态应该如何管理，优先使用派生状态，并且在适当的时候利用 useMemo、reselect 等库去优化他们。dont-sync-state-derive-it React Hooks 的自定义 hook 中，如何利用 reducer 的模式提供更加灵活的数据管理，让用户拥有数据的控制权。the-state-reducer-pattern-with-react-hooks TypeScript 自从 Vue3 横空出世以来，TypeScript 好像突然就火了。这是一件好事，推动前端去学习强类型语言，开发更加严谨。并且第三方包的 ts 类型支持的加入，让我们甚至很多时候都不再需要打开文档对着 api 撸了。 关于 TypeScript 学习，其实几个月前我还对于这门 JavaScript 的超集一窍不通，经过两三个月的静心学习，我能够去理解一些相对复杂的类型了， 可以说 TypeScript 的学习和学一个库或者学一个框架是完全不同的， 入门 掘金的小册，深入浅出 TypeScript：从基础知识到类型编程，讲解的非常通俗易懂。 ![][img-2] 除了官方文档以外，还有一些比较好的中文入门教程。TypeScript Handbook 入门教程 TypeScript Deep Dive 非常高质量的英文入门教学。TypeScript Deep Dive 工具泛型在日常开发中都非常的常用，必须熟练掌握。TS 一些工具泛型的使用及其实现 视频课程，还是黄轶大佬的，并且这个课程对于单元测试、前端手写框架、以及网络请求原理都非常有帮助。基于 TypeScript 从零重构 axios 进阶 这五篇文章里借助非常多的案例，为我们讲解了 ts 的一些高级用法，请务必反复在 ide 里尝试，理解，不懂的概念及时回到文档中补习。巧用 TypeScript 系列 一共五篇 TS 进阶非常重要的一点，条件类型，很多泛型推导都需要借助它的力量。conditional-types-in-typescript 以及上面那个大佬博客中的所有 TS 文章。https://mariusschulz.com 实战 一个参数简化的实战，涉及到的高级知识点非常多。 TypeScript 的高级类型（Advanced Type） Conditional Types (条件类型) Distributive conditional types (分布条件类型) Mapped types（映射类型） 函数重载 br/>TypeScript 参数简化实战 实现一个简化版的 Vuex，同样知识点结合满满。 TypeScript 的高级类型（Advanced Type） TypeScript 中利用泛型进行反向类型推导。(Generics) Mapped types（映射类型） Distributive Conditional Types（条件类型分配） TypeScript 中 Infer 的实战应用（Vue3 源码里 infer 的一个很重要的使用）br/>TS 实现智能类型推导的简化版 Vuex 刻意训练 它几乎是一门新的语言（在类型世界里来说），需要你花费很大的精力去学好它。 我对于 TypeScript 的学习建议其实就是一个关键词：刻意训练，在过基础概念的时候，不厌其烦的在vscode中敲击，理解，思考。在基础概念过完以后去寻找实践文章，比如我上面进阶和实战部分推荐的几篇，继续刻意训练，一定要堆积代码量，学习一门新的语言是不可能靠看文档获得成功的。 我会建立一个仓库，专门记录我遇到的 TypeScript 的有趣代码，自己动手敲一遍，并且深入理解。 能力分级 其实 TypeScript 的能力也是两级分化的，日常写业务来说，你定义一些 interface，配合 React.FC 这种官方内置的类型也就跑通了，没什么特别难的点。 但是如果是造轮子呢？如果你自己写了一个工具库，并且类型比较复杂，你能保证推导出来吗？亦或者就拿 Vue3 来说，ref 是一个很复杂的嵌套类型， 假如我们这样定义一个值const value = ref(ref(2))，对于嵌套的 ref，Vue3 会做一层拆包，也就是说其实ref.value会是 2， 那么它是如何让 ts 提示出 value 的类型是 number 的呢？ 如果你看到源码里的这段代码，你只有基础的话，保证懵逼。 // Recursively unwraps nested value bindings. export type UnwrapRef = { cRef: T extends ComputedRef ? UnwrapRef : T ref: T extends Ref ? UnwrapRef : T array: T object: { [K in keyof T]: UnwrapRef } }[T extends ComputedRef ? 'cRef' : T extends Array ? 'array' : T extends Ref | Function | CollectionTypes | BaseTypes ? 'ref' // bail out on types that shouldn't be unwrapped : T extends object ? 'object' : 'ref'] 业务开发人员 如果短期内你对自己的要求是能上手业务，那么你理解 TypeScript 基础的interface和type编写和泛型的普通使用（可以理解为类型系统里的函数传参）也已经足够。 框架开发人员 但是长期来看，如果你的目的是能够自己编写一些类型完善的库或框架，或者说你在公司扮演前端架构师、轮子专家等等角色，经常需要写一些偏底层的库给你的小伙伴们使用，那么你必须深入学习，这样才能做到给你的框架使用用户完美的类型体验。 面试题 TypeScript 相关的面试题我见得不多，不过力扣中国的面试题算是难度偏高的，其中有一道 TS 的面试题，可以说是实用性和难度都有所兼顾，简单来说就是解包。 // 解开参数和返回值中的Promise asyncMethod(input: Promise): Promise> ↓ asyncMethod(input: T): Action // 解开参数中的Action syncMethod(action: Action): Action ↓ syncMethod(action: T): Action 我在高强度学习了两三个月 TS 的情况下，已经能把这道题目相对轻松的解出来，相信这也是说明我的学习路线没有走偏（题解就不放了，尊重面试题，其实就是考察了映射类型和infer的使用）。力扣面试题 代码质量 代码风格 在项目中集成 Prettier + ESLint + Airbnb Style Guide integrating-prettier-eslint-airbnb-style-guide-in-vscode 在项目中集成 ESLint with Prettier, TypeScript 高质量架构 如何重构一个过万 Star 开源项—BetterScroll，是由滴滴的大佬嵇智所带来的，无独有偶的是，这篇文章除了详细的介绍一个合格的开源项目应该做到的代码质量保证，测试流程，持续集成流程以外，也体现了他的一些思考深度，非常值得学习。如何重构一个过万 Star 开源项目—BetterScroll Git 提交信息 很多新手在提交 Git 信息的时候会写的很随意，比如fix、test、修复，这么糊弄的话是会被 leader 揍的！[译] 如何撰写 Git 提交信息Git-Commit-Log 规范（Angular 规范）commitizen 规范流程的 commit 工具，规范的 commit 格式也会让工具帮你生成友好的changelog 构建工具 webpack 基础和优化深入浅出 webpack 滴滴前端工程师的 webpack 深入源码分析系列，非常的优秀。webpack 系列之一总览 性能优化 推荐修言大佬的一本小册，真的是讲的很好很好了，从webpack到网络到dom操作，全方位的带你做一些性能优化实战。这本小册我当时看的时候真的是完全停不下来，修言大佬的风格既轻松又幽默。但是讲解的东西却能让你受益匪浅。 谷歌开发者性能优化章节，不用多说了吧？很权威了。左侧菜单栏里还有更多相关内容，可以按需选择学习。user-centric-performance-metrics 详谈合成层，合成层这个东西离我们忽远忽近，可能你的一个不小心的操作就造成层爆炸，当然需要仔细关注啦。起码，在性能遇到瓶颈的时候，你可以打开 chrome 的layer面板，看看你的页面到底是怎么样的一个层分布。详谈层合成（composite） 刘博文大佬的性能优化指南，非常清晰的讲解了网页优化的几个重要的注意点。让你的网页更丝滑 社区讨论 作为一个合格的前端工程师，一定要积极的深入社区去了解最新的动向，比如在twitter上关注你喜欢的技术开发人员，如 Dan、尤雨溪。 另外 Github 上的很多 issue 也是宝藏讨论，我就以最近我对于 Vue3 的学习简单的举几个例子。 为什么 Vue3 不需要时间切片？ 尤雨溪解释关于为什么在 Vue3 中不加入 React 时间切片功能？并且详细的分析了 React 和 Vue3 之间的一些细节差别，狠狠的吹了一波 Vue3（爱了爱了）。Why remove time slicing from vue3? Vue3 的composition-api到底好在哪？ Vue3 的 functional-api 相关的 rfc，尤大舌战群儒，深入浅出的为大家讲解了 Vue3 的设计思路等等。Amendment proposal to Function-based Component API Vue3composition-api的第一手文档 vue-composition-api 的 rfc 文档，在国内资料还不齐全的情况下，我去阅读了vue-composition-api-rfc 英文版文档，对于里面的设计思路叹为观止，学到了非常非常多尤大的思想。 总之，对于你喜欢的仓库，都可以去看看它的 issue 有没有看起来感兴趣的讨论，你也会学到非常多的东西。并且你可以和作者保持思路上的同步，这是非常难得的一件事情。 关于 Hook 的一些收获 我在狠狠的吸收了一波尤大对于 Vue3 composition-api的设计思路的讲解，新旧模式的对比以后，这篇文章就是我对 Vue3 新模式的一些见解。Vue3 Composition-Api + TypeScript + 新型状态管理模式探索。 在 Vue2 里，可以通过plugin先体验composition-api，截取这篇文章对应的实战项目中的一小部分代码吧： import { createComponent } from '@vue/composition-api'; import Books from '@/components/Books.vue'; import { useAsync } from '@/hooks'; import { getBooks } from '@/hacks/fetch'; import { useBookListInject } from '@/context'; export default createComponent({ name: 'books', setup() { const { books, setBooks, booksAvaluable } = useBookListInject(); const loading = useAsync(async () => { const requestBooks = await getBooks(); setBooks(requestBooks); }); return { booksAvaluable, loading }; }, components: { Books, }, }); .content { max-width: 700px; margin: auto; } 本实战对应仓库： vue-bookshelf 并且由于它和React Hook在很多方面的思想也非常相近，这甚至对于我在React Hook上的使用也大有裨益，比如代码组织的思路上， 在第一次使用Hook开发的时候，大部分人可能还是会保留着以前的思想，把state集中起来定义在代码的前一大段，把computed集中定义在第二段，把mutation定义在第三段，如果不看尤大对于设计思想的讲解，我也一直是在这样做。 但是为什么 Logical Concerns 优于 Vue2 和 React Class Component 的 Option Types？看完 detailed-design 这个章节你就全部明白了，并且这会融入到你日常开发中去。 总之，看完这篇以后，我果断的把公司里的首屏组件的一坨代码直接抽成了 n 个自定义 hook，维护效率提升简直像是坐火箭。 当然，社区里的宝藏 issue 肯定不止这些，我只是简单的列出了几个，但就是这几个都让我的技术视野开阔了很多，并且是真正的融入到公司的业务实战中去，是具有业务价值的。希望你养成看 issue，紧跟英文社区的习惯，Github issue 里单纯的技术探讨氛围，真的是国内很少有社区可以媲美的。 function AppInner({ children }) { const [menus, setMenus] = useState({}); // 用户信息 const user = useUser(); // 主题能力 useTheme(); // 权限获取 useAuth({ setMenus, }); // 动态菜单也需要用到菜单的能力 useDynamicMenus({ menus, setMenus, }); return ( {children} ); } 可以看到，Hook在代码组织的方面有着得天独厚的优势，甚至各个模块之间值的传递都是那么的自然，仅仅是函数传参而已。总之，社区推出一些新的东西，它总归是解决了之前的一些痛点。我们跟着大佬的思路走，一定有肉吃。 Tree Shaking 的 Issue 相学长的文章你的 Tree-Shaking 并没什么卵用中，也详细的描述了他对于副作用的一些探寻过程，在 UglifyJS 的 Issue 中找到了最终的答案，然后贡献给中文社区，这些内容最开始不会在任何中文社区里出现，只有靠你去探寻和发现。 学习方法的转变 从初中级前端开始往高级前端进阶，有一个很重要的点，就是很多情况下国内社区能找到的资料已经不够用了，而且有很多优质资料也是从国外社区二手、三手翻译过来的，翻译质量也不能保证。 这就引申出我们进阶的第一个点，开始接受英文资料。 这里很多同学说，我的英文能力不行啊，看不懂。其实我想说，笔者的英语能力也很一般，从去年开始我立了个目标，就是带着划词翻译插件也要开始艰难的看英文文章和资料，遇到不懂的单词就划出来看两眼（没有刻意去背），第五六次遇见这个单词的时候，就差不多记得它是什么意思了。 半年左右的时间下来，（大概保持每周 3 篇以上的阅读量）能肉眼可见的感觉自己的英语能力在进步，很多时候不用划词翻译插件，也可以完整的阅读下来一段文章。 这里是我当时阅读英文优质文章的一些记录， 英文技术文章阅读 后面英文阅读慢慢成了一件比较自然的事情，也就没有再刻意去记录，前期可以用这种方式激励自己。 推荐两个英文站点吧，有很多高质量的前端文章。 dev.tomedium medium 可能需要借助一些科学工具才能查看，但是里面的会员付费以及作者激励机制使得文章非常的优质。登录自己的谷歌账号即可成为会员，前期可能首页不会推荐一些前端相关的文章，你可以自己去搜索关键字如Vue、React、Webpack，任何你兴趣的前端技术栈，不需要过多久你的首页就会出现前端的推荐内容。好好享受这个高质量的英文社区吧。 关于实践 社区有很多大佬实力很强，但是对新手写的代码嗤之以鼻，认为有 any 的就不叫 TypeScript、认为没有单元测试就没资格丢到 Github 上去。这种言论其实也不怪他们，他们也只是对开源软件的要求高到偏执而已。但是对于新手学习来说，这种言论很容易对大家造成打击，导致不敢写 ts，写的东西不敢放出来。其实大可不必，工业聚 对于这些观点就发表了一篇很好的看法，让我觉得深受打动，也就是这篇文章开始，我慢慢的把旧项目用 ts 改造起来，慢慢的进步。 Vue 3.0 公开代码之后…… 总结 本篇文章是我在这一年多的学习经历抽象中总结出来，还有很多东西我会陆续加入到这篇文章中去。 希望作为初中级前端工程师的你，能够有所收获。如果能够帮助到你就是我最大的满足。 未完待续... 持续更新中。 ❤️感谢大家 如果本文对你有帮助，就点个赞支持下吧，你的「赞」是我创作的动力。 关注公众号「前端从进阶到入院」即可加我好友，我拉你进「前端进阶交流群」，大家一起共同交流和进步。 讲的好，我也是感觉遇到了瓶颈，要有个方向 感谢总结与分享 根据我在 vue2.6.11 版本源码的观察情况，nextTick 在 2.5 版本之后就已经取消宏任务统一使用微任务了… 2.6.11 我没看，3.0 我看了也是全部微任务了。时代的洪流啊~ https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js 这个版本我刚看了一下，在最坏的情况下还是回退到宏任务。 正则要掌握到什么程度呀。 不怎么需要掌握正则 如果都明白了自然也就是高级工程师了 这就是我发文章的目的&#x1F604; 这个是真的不错，谢谢作者 我是掘金的 Yiming 君，在这里又见面了，这个点儿正在学习 diff 算法中~ 每一项都需要花时间 积累很重要 两年能把这些全掌握算挺不错了，另外我最近有点疑惑，前端基于 vue 和 react 的发展，总觉得有点怪怪的，局限？或者说我比较疑惑程序员的发展之路是什么（因为最近正美那事导致我反思比较多），我之前得出的结论是不管技术如何，前端还是后端，主要的是如何快速积累财富&#x1F600; 这个好像是老生常谈的话题了，建议搜一下一些资深程序猿给出的建议，我也还在摸索中。 ![][img-5] 感谢 如何使用Gitbook的小例子 "},"Base/":{"url":"Base/","title":"前端基础","keywords":"","body":"前端基础 "},"Base/手写call1.html":{"url":"Base/手写call1.html","title":"类型转换","keywords":"","body":"类型转换 "},"Base/EventLoop.html":{"url":"Base/EventLoop.html","title":"EventLoop","keywords":"","body":"EventLoop 任务队列 同步任务优先于异步任务。 在同步队列被执行完之前，任何异步的操作都不会被执行 同步任务执行完之后才执行异步任务 运行机制 for(vari=0;i 涉及异步队列涉及的时间，浏览器发现settimeout不会马上放到运行栈里去，for循环体执行完才去执行异步队列，异步队列没有到时间去收编settimeout，再等待事件循环里处理 Event Loop事件循环 运行栈运行的是同步任务。 浏览器识别了事件是一个异步任务，他不会把他放在运行栈里，而是拿走。 拿走了之后也不是立马放在异步队列中，同步任务执行完以后，再放入异步队列。 运行栈里没有任务了，就开始执行异步任务。 执行完后如果运行栈里没有任务了，再监听异步队列。 这个循环的过程就是EventLoop 异步任务 setTimeout 和setInterval DOM事件 Promise for (var i = 0; i 总结： 理解js单线程的概念 一个时间只能干一件事 理解任务队列 EventLoop 哪些会被放入异步队列 放入异步队列的时机 来个&#x1F330; button.addEventListener('click', () => { Promise.resolve(). then(() => console. log( 'Microtask 1')); console.log( 'Listener 1' ); }); button.addEventL istener( 'click', () => { P romise. resolve(). then(() => console. log( 'Microtask 2')); console.log( 'Listener 2'); }); //执行顺序是 Listener 1 ->Microtask 1 ->Listener 2->Microtask 2 这个题目容易错的地方是，当执行第一个监听事件的时候，js执行完，调用栈已经清空了，所以马上就执行了微任务。 改变下 button.addEventListener('click', () => { Promise.resolve(). then(() => console. log( 'Microtask 1')); console.log( 'Listener 1' ); }); button.addEventL istener( 'click', () => { P romise. resolve(). then(() => console. log( 'Microtask 2')); console.log( 'Listener 2'); }); button.onClick() //执行这个点击事件 //执行顺序是 Listener 1 ->Listener 2 -> Microtask 1 -> Microtask 2 但只点击button.onClick() 这个点击事件，调用栈没有执行结束前，必须把同步任务都执行结束，调用栈清空后执行微任务 "},"Base/CSS.html":{"url":"Base/CSS.html","title":"CSS系列","keywords":"","body":"CSS系列 "},"Base/布局系列.html":{"url":"Base/布局系列.html","title":"布局系列","keywords":"","body":"布局系列 "},"Design/":{"url":"Design/","title":"前端设计模式","keywords":"","body":"前端设计模式 "},"Design/工程模式.html":{"url":"Design/工程模式.html","title":"工厂模式","keywords":"","body":"工厂模式 "},"Design/单一模式.html":{"url":"Design/单一模式.html","title":"单一模式","keywords":"","body":"单一模式 "},"DiyCode/":{"url":"DiyCode/","title":"手撕代码","keywords":"","body":"手撕代码 "},"DiyCode/手写call.html":{"url":"DiyCode/手写call.html","title":"手写call","keywords":"","body":"手写call "},"DiyCode/手写bind.html":{"url":"DiyCode/手写bind.html","title":"手写bind","keywords":"","body":"手写bind "},"Algorithm/":{"url":"Algorithm/","title":"前端算法","keywords":"","body":"前端算法 "},"Algorithm/前端算法.html":{"url":"Algorithm/前端算法.html","title":"前端算法","keywords":"","body":"前端算法 前端还要学算法？必须学，而且必须狠狠地学。现在去大厂面试，数据结构与算法已经是标配，要是不会的话，那基本与大厂无缘了。 作为一名前端，虽然在平常开发中很少写算法，但当我们需要深入前端框架、开发语言、开源库时，懂算法将大大提高我们看源码的能力。例如 ： virtual-dom diff 算法做了一些约定，后将原先 O(n3) 的时间复杂度降到了O(n) ，核心原理就是一个树的深度优先搜索 babel 这些就是一些编译原理的 parser 生成抽象语法树的知识，再将抽象语法树进行转换操作生成文件 浏览器的 history，底层可以使用栈来实现 webpack 中利用 tree-shaking 优化 v8 中的调用栈、消息队列等等 这些就大量使用了算法，看懂了就能更好的了解它们的性能，更高效的解决问题，提升我们的代码质量与思维视野，进阶到更高 Level，赚更多钱💰💰💰。 所以说，学算法是每个前端进阶必备！⛽️⛽️⛽️ 现在市面上的算法资料很多，但针对前端的算法资料少之又少，所以，这里我整理了一份适用于前端的数据结构与算法系列，希望能帮助你从0到1构建完整的数据结构与算法体系。 本系列预估一共有40多篇： 前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？ 前端进阶算法2：从Chrome V8源码看JavaScript数组（附赠腾讯面试题） 前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法 前端进阶算法4：链表原来如此简单（+leetcode刷题） 深入掌握算法 数组篇 图解leetcode88：合并两个有序数组 字节&leetcode1：两数之和 腾讯：数组扁平化、去重、排序 leetcode349：给定两个数组，编写一个函数来计算它们的交集 leetcode146：设计和实现一个LRU（最近最少使用）缓存机制 阿里算法题：编写一个函数计算多个数组的交集 链表 leetcode21：合并两个有序链表 有赞&leetcode141：判断一个单链表是否有环 图解leetcode206：反转链表 leetcode876：求链表的中间结点 leetcode19：删除链表倒数第 n 个结点 感谢 想要更多更快的学习本系列，可以关注公众号「前端瓶子君」😊😊😊 "},"Algorithm/统计算法的执行效率和资源消耗.html":{"url":"Algorithm/统计算法的执行效率和资源消耗.html","title":"统计算法的执行效率和资源消耗","keywords":"","body":"统计算法的执行效率和资源消耗 简介 前端还要学算法？必须学，而且必须狠狠地学。现在去大厂面试，数据结构与算法已经是标配，要是不会的话，那基本与大厂无缘了。 作为一名前端，虽然在平常开发中很少写算法，但当我们需要深入前端框架、开发语言、开源库时，懂算法将大大提高我们看源码的能力。例如 react 的 diff 算法、webpack 中利用 tree-shaking 优化、v8 中的调用栈、消息队列等，这些就大量使用了算法，看懂了就能更好的了解它们的性能，更高效的解决问题，进阶到更高 Level，赚更多钱。 现在市面上的算法资料很多，但针对前端的算法资料少之又少，所以，这里我整理了一份适用于前端的数据结构与算法系列，希望能帮助你从0到1构建完整的数据结构与算法体系。 本系列预估一共有40多篇，本篇是第一篇。想要更多更快的学习本系列，可以关注公众号「前端瓶子君」和我的「Github（点击查看）」 一、为什么引入复杂度分析 我们知道，好的数据结构与算法能够大大缩短代码的执行时间与存储空间，那么我们如何去衡量它喃？本节就主要介绍算法性能的衡量指标—复杂度分析。 ==判断一段代码执行的效率最简单最直观的方式就是把它放在机器上执行一遍，自然就会得到算法的执行时间与占用内存大小。那么为什么还要引入复杂度分析喃？== 这主要是因为，通过机器上运行代码来统计算法的性能，有很大的局限性，它容易受测试环境、数据规模影响： 统计结果易受测试环境影响：不同系统、处理器的机器测试结果可能出现很大的不同 统计结果易受数据本身、数据规模影响：不同的数据、不同长度的数据都可能对测试结果产生巨大的影响 而这些都不是我们想要看到的。==我们需要的是不受外在因素影响的、大致的估计算法执行效率的方法==。这就是使用复杂度分析的原因。 二、如何表示复杂度 如何表示算法复杂度，具体来讲就是代码执行的时间、执行消耗的存储空间。例如： function cal(n) { let sum = 0; // 1 unit_time let i = 0; // 1 unit_time for(; i 从 CPU 的角度看，每段代码不过是读写数据或操作数据，尽管每次操作 CPU 执行的个数、执行的时间都不同，但我们粗咯把每次执行的时间都一致，称为 unit_time 。 所以上述代码总共执行 (2n+2)*unit_time 时间，即：T(n)=(2n+2)*unit_time ，所以，我们可以写成： T(n) = O(f(n)) 其中： n：表示数据规模的大小 f(n)：表示每行代码执行的次数总和 O：表示代码的执行时间 T(n) 与 f(n) 表达式成正比 当 n 很大时，例如 10000，甚至更大，T(n) = O(f(n)) 可以表示为 T(n) = O(n) 。 这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 三、时间复杂度 当 n 无限大时，时间复杂度 T(n) 受 n 的最高数量级影响最大，与f(n) 中的常量、低阶、系数关系就不那么大了。所以我们分析代码的时间复杂度时，仅仅关注代码执行次数最多的那段就可以了。 看一个例子： function fun1(n) { let sum = 0,i = 0; for(; i fun1 中第1行都是常量，对 n 的影响不大，所以总的时间复杂度要看第2、3行的循环，即时间复杂度为： O(n) 。 fun2 中循环1的时间复杂度为 O(n) ，循环2的时间复杂度为 O(n2)，当 n 趋于无穷大时，总体的时间复杂度要趋于 O(n2) ，即上面代码的时间复杂度是 O(n2)。 fun3 的时间复杂度是 O(n * T(fun)) = O(n*n)，即 O(n2) 。 所以：T(c+n)=O(n)，T(m+n)=O(max(m, n))，T(n) = T1(n) T2(m) = O(nm)，其中 c 为常量 常见复杂度（按数量阶递增） 多项式量级： 常量阶： O(1)：当算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1) 对数阶：O(logn): 简单介绍一下 let i=1; while (i 每次循环 i 都乘以 2 ，直至 i > n ，即执行过程是：20、21、22、…、2k、…、2x、 n 所以总执行次数 x ，可以写成 2x = n ，则时间复杂度为 O(log2n) 。这里是 2 ，也可以是其他常量 k ，时间复杂度也是： O(log3n) = O(log32 * log2n) = O(log2n) 线性阶：O(n) 线性对数阶：O(nlogn) 平方阶、立方阶、….、k次方阶：O(n2)、O(n3)、…、O(nk) 非多项式量阶： 指数阶：O(2k) 阶乘阶：O(n!) 四、空间复杂度 时间复杂度表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度表示算法的存储空间与数据规模之间的增长关系。例如： function fun(n) { let a = []; for (let i = 0; i 以上代码我们可以清晰的看出代码执行的空间为 O(1+n) = O(n)，即为 i 及数组 a 占用的储存空间。 所以，空间复杂度分析比时间复杂度分析要简单很多。 五、平均时间复杂度 时间复杂度受数据本身影响，还分为： 最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度 最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度 平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量 六、参考资料 极客时间的数据结构与算法之美 学习JavaScript数据结构与算法 "},"Algorithm/从Chrome V8源码看JavaScript数组.html":{"url":"Algorithm/从Chrome V8源码看JavaScript数组.html","title":"从Chrome V8源码看JavaScript数组","keywords":"","body":"从Chrome V8源码看JavaScript数组 简介 数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表，例如树、图、堆等，它表示的结构都非线性。 本节主要介绍 JavaScript 数组，在开始本章节前，思考一个问题： 我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。这是为什么喃？ 本节从 Chrome v8 源码角度回答这个问题，分为四个方面： 数组基础入门 JavaScript 中，数组为什么可以保存不同类型？ JavaScript 中，数组是如何存储的喃？ JavaScript 中，数组的动态扩容与减容（ FastElements ） 下面进入正题吧！（文末有惊喜）&#x1F60A; 想要更多更快的学习本系列，可以关注公众号「前端瓶子君」和我的「Github（点击查看）」 一、数组（基础） 一种最基础的数据结构，每种编程语言都有，它编号从 0 开始，代表一组连续的储存结构，用来储存同一种类型的数据。 let arr = [1, 2, 3] 它的这种特定的存储结构（连续存储空间存储同一类型数据）决定了： 优点 随机访问：可以通过下标随机访问数组中的任意位置上的数据 缺点 对数据的删除和插入不是很友好 查找： 根据下标随机访问的时间复杂度为 O(1)； 插入或删除： 时间复杂度为 O(n)； 在 JavaScript 中的数组几乎是万能的，它不光可以作为一个普通的数组使用，可以作为栈或队列使用。 数组： let array = [1, 2, 3] 栈： let stack = [1, 2, 3] // 进栈 stack.push(4) // 出栈 stcak.pop() 队列： let queue = [1, 2, 3] // 进队 queue.push(4) // 出队 queue.shift() 二、JavaScript 中，数组可以保存不同类型值 看一下 Chrome v8 源码： // The JSArray describes JavaScript Arrays // Such an array can be in one of two modes: // - fast, backing storage is a FixedArray and length 我们可以看到 JSArray 是继承自 JSObject 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部也是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。 三、JavaScript 中，数组的存储 // The JSArray describes JavaScript Arrays // Such an array can be in one of two modes: // - fast, backing storage is a FixedArray and length JSArray 继承于 JSObject ，从注释上看，它有两种存储方式： fast：存储结构是 FixedArray ，并且数组长度 ，push 或 pop 时可能会伴随着动态扩容或减容 slow：存储结构是 HashTable（哈希表），并且数组下标作为 key fast 模式下数组在源码里面叫 FastElements ，而 slow 模式下的叫做 SlowElements 。 1. 快数组（FastElements） FixedArray 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 push 时， JSArray 会进行动态的扩容，以存储更多的元素。 2. 慢数组（SlowElements） 慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间，但需要额外维护一个哈希表，与快数组相比，性能相对较差。 // src/objects/dictionary.h class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) Dictionary : public HashTable { using DerivedHashTable = HashTable; public: using Key = typename Shape::Key; // Returns the value at entry. inline Object ValueAt(InternalIndex entry); inline Object ValueAt(const Isolate* isolate, InternalIndex entry); // ... }; 从源码中可以看出，它的内部就是一个 HashTable。 3. 什么时候会从 fast 转变为 slow 喃？ 从 Chrome V8 源码上看， // src/objects/js-objects.h static const uint32_t kMaxGap = 1024; // src/objects/dictionary.h // JSObjects prefer dictionary elements if the dictionary saves this much // memory compared to a fast elements backing store. static const uint32_t kPreferFastElementsSizeFactor = 3; // src/objects/js-objects-inl.h // If the fast-case backing storage takes up much more memory than a dictionary // backing storage would, the object should have slow elements. // static static inline bool ShouldConvertToSlowElements(uint32_t used_elements, uint32_t new_capacity) { uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor * NumberDictionary::ComputeCapacity(used_elements) * NumberDictionary::kEntrySize; // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组 return size_threshold = JSObject::kMaxGap) return true; *new_capacity = JSObject::NewElementsCapacity(index + 1); DCHECK_LT(index, *new_capacity); // TODO(ulan): Check if it works with young large objects. if (*new_capacity 所以，当处于以下情况时，快数组会被转变为慢数组： 当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity >= 1024） 快数组新容量是扩容后的容量 3 倍之多时 例如：向快数组里增加一个大索引同类型值 var arr = [1, 2, 3] arr[2000] = 10; 当往 arr 增加一个 2000 的索引时，arr 被转成慢数组。节省了大量的内存空间（从索引为 2 到索引为 2000）。 4. 什么时候会从 slow 转变为 fast 喃？ 我们已经知道在什么时候会出现由快变慢，那由慢变快就很简单了 static bool ShouldConvertToFastElements(JSObject object, NumberDictionary dictionary, uint32_t index, uint32_t* new_capacity) { // If properties with non-standard attributes or accessors were added, we // cannot go back to fast elements. if (dictionary.requires_slow_elements()) return false; // Adding a property with this index will require slow elements. if (index >= static_cast(Smi::kMaxValue)) return false; if (object.IsJSArray()) { Object length = JSArray::cast(object).length(); if (!length.IsSmi()) return false; *new_capacity = static_cast(Smi::ToInt(length)); } else if (object.IsJSArgumentsObject()) { return false; } else { *new_capacity = dictionary.max_number_key() + 1; } *new_capacity = Max(index + 1, *new_capacity); uint32_t dictionary_size = static_cast(dictionary.Capacity()) * NumberDictionary::kEntrySize; // Turn fast if the dictionary only saves 50% space. return 2 * dictionary_size >= *new_capacity; } 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间，则会转变为快数组 四、JavaScript 中，数组的动态扩容与减容（FastElements） 默认空数组初始化大小为 4 : // Number of element slots to pre-allocate for an empty array. static const int kPreallocatedArrayElements = 4; 在 JavaScript 中，当数组执行 push 操作时，一旦发现数组内存不足，将进行扩容。 在 Chrome 源码中， push 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。 计算新容量的函数： // js-objects.h static const uint32_t kMinAddedElementsCapacity = 16; // code-stub-assembler.cc Node* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity, ParameterMode mode) { CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode)); Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode); Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode); Node* padding = IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode); return IntPtrOrSmiAdd(new_capacity, padding, mode); } 所以扩容后新容量计公式为： new_capacity = old_capacity /2 + old_capacity + 16 即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 push 第 5 个的时候，容量将会变成： new_capacity = 4 / 2 + 4 + 16 = 22 接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。 所以，扩容可以分为以下几步： push 操作时，发现数组内存不足 申请 new_capacity = old_capacity /2 + old_capacity + 16 那么长度的内存空间 将数组拷贝到新内存中 把新元素放在当前 length 位置 数组的 length + 1 返回 length 整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。 当数组执行 pop 操作时，会判断 pop 后数组的容量，是否需要进行减容。 不同于数组的 push 使用汇编实现的， pop 使用 c++ 实现的。 判断是否进行减容： if (2 * length heap()->RightTrimFixedArray(*backing_store, capacity - length); } else { // Otherwise, fill the unused tail with holes. BackingStore::cast(*backing_store)->FillWithHoles(length, old_length); } 所以，当数组 pop 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。 所以，减容可以分为以下几步： pop 操作时，获取数组 length 获取 length - 1 上的元素（要删除的元素） 数组 length - 1 判断数组的总容量是否大于等于 length - 1 的 2 倍 是的话，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，并做好标记，等待 GC 回收 不是的话，用 holes 对象填充 返回要删除的元素 五、解答开篇问题 JavaScript 中， JSArray 继承自 JSObject ，或者说它就是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。 六、最后附赠一道前端面试题（腾讯）：数组扁平化、去重、排序 关于 Array 的属性、方法这里不再做介绍，详看 MDN Array 。 面试题： 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 答案： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10] // 扁平化 let flatArr = arr.flat(4) // 去重 let disArr = Array.from(new Set(flatArr)) // 排序 let result = disArr.sort(function(a, b) { return a-b }) console.log(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 关于 Set 请查阅 Set、WeakSet、Map及WeakMap 参考链接： 探究JS V8引擎下的“数组”底层实现 从Chrome源码看JS Array的实现 "},"Algorithm/LRU算法.html":{"url":"Algorithm/LRU算法.html","title":"LRU算法","keywords":"","body":"LRU算法 引言 这个标题已经很明显的告诉我们：前端需要了解 LRU 算法！ 这也是前端技能的亮点，当面试官在问到你前端开发中遇到过哪些算法，你也可以把这部分丢过去！ 本节按以下步骤切入： 由浏览器缓存策略引出 LRU 算法原理 然后走进 vue 中 keep-alive 的应用 接着，透过 vue 中 keep-alive 源码看 LRU 算法的实现 最后，来一道 leetcode 题目，我们来实现一个 LRU 算法 按这个步骤来，完全掌握 LRU 算法，点亮前端技能，下面就开始吧&#x1F447; 一、LRU 缓存淘汰策略 缓存在计算机网络上随处可见，例如：当我们首次访问一个网页时，打开很慢，但当我们再次打开这个网页时，打开就很快。 这就涉及缓存在浏览器上的应用：浏览器缓存。当我们打开一个网页时，例如 https://github.com/sisterAn/JavaScript-Algorithms ，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存文件，并直接结束请求，不会再去服务器上下载。如果不存在，才会去服务器请求。 其实，浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是浏览器缓存淘汰策略，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。 LRU （ Least Recently Used ：==最近最少使用== ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 如果数据最近被访问过，那么将来被访问的几率也更高 ，优先淘汰最近没有被访问到的数据。 画个图帮助我们理解： 二、LRU 在 keep-alive (Vue) 上的实现 1. keep-alive keep-alive 在 vue 中用于实现组件的缓存，当组件切换时不会对当前组件进行卸载。 最常用的两个属性：include 、 exculde ，用于组件进行有条件的缓存，可以用逗号分隔字符串、正则表达式或一个数组来表示。 在 2.5.0 版本中，keep-alive 新增了 max 属性，用于最多可以缓存多少组件实例，一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉，看，这里就应用了 LRU 算法。即在 keep-alive 中缓存达到 max，新增缓存实例会优先淘汰最近没有被访问到的实例&#x1F389;&#x1F389;&#x1F389; 下面我们透过 vue 源码看一下具体的实现&#x1F447; 2. 从 vue 源码看 keep-alive 的实现 export default { name: \"keep-alive\", // 抽象组件属性 ,它在组件实例建立父子关系的时候会被忽略,发生在 initLifecycle 的过程中 abstract: true, props: { // 被缓存组件 include: patternTypes, // 不被缓存组件 exclude: patternTypes, // 指定缓存大小 max: [String, Number] }, created() { // 初始化用于存储缓存的 cache 对象 this.cache = Object.create(null); // 初始化用于存储VNode key值的 keys 数组 this.keys = []; }, destroyed() { for (const key in this.cache) { // 删除所有缓存 pruneCacheEntry(this.cache, key, this.keys); } }, mounted() { // 监听缓存（include）/不缓存（exclude）组件的变化 // 在变化时，重新调整 cache // pruneCache：遍历 cache，如果缓存的节点名称与传入的规则没有匹配上的话，就把这个节点从缓存中移除 this.$watch(\"include\", val => { pruneCache(this, name => matches(val, name)); }); this.$watch(\"exclude\", val => { pruneCache(this, name => !matches(val, name)); }); }, render() { // 获取第一个子元素的 vnode const slot = this.$slots.default; const vnode: VNode = getFirstComponentChild(slot); const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions; if (componentOptions) { // name 不在 inlcude 中或者在 exlude 中则直接返回 vnode，否则继续进行下一步 // check pattern const name: ?string = getComponentName(componentOptions); const { include, exclude } = this; if ( // not included (include && (!name || !matches(include, name))) || // excluded (exclude && name && matches(exclude, name)) ) { return vnode; } const { cache, keys } = this; // 获取键，优先获取组件的 name 字段，否则是组件的 tag const key: ?string = vnode.key == null ? // same constructor may get registered as different local components // so cid alone is not enough (#3269) componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : \"\") : vnode.key; // -------------------------------------------------- // 下面就是 LRU 算法了， // 如果在缓存里有则调整， // 没有则放入（长度超过 max，则淘汰最近没有访问的） // -------------------------------------------------- // 如果命中缓存，则从缓存中获取 vnode 的组件实例，并且调整 key 的顺序放入 keys 数组的末尾 if (cache[key]) { vnode.componentInstance = cache[key].componentInstance; // make current key freshest remove(keys, key); keys.push(key); } // 如果没有命中缓存,就把 vnode 放进缓存 else { cache[key] = vnode; keys.push(key); // prune oldest entry // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个 if (this.max && keys.length > parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode); } } // keepAlive标记位 vnode.data.keepAlive = true; } return vnode || (slot && slot[0]); } }; // 移除 key 缓存 function pruneCacheEntry ( cache: VNodeCache, key: string, keys: Array, current?: VNode ) { const cached = cache[key] if (cached && (!current || cached.tag !== current.tag)) { cached.componentInstance.$destroy() } cache[key] = null remove(keys, key) } // remove 方法（shared/util.js） /** * Remove an item from an array. */ export function remove (arr: Array, item: any): Array | void { if (arr.length) { const index = arr.indexOf(item) if (index > -1) { return arr.splice(index, 1) } } } keep-alive源码路径 在 keep-alive 缓存超过 max 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 cache 对象用于保存缓存的组件实例及 key 值，keys 数组用于保存缓存组件的 key ，当 keep-alive 中渲染一个需要缓存的实例时： 判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 key 在 keys 中的位置（移除 keys 中 key ，并放入 keys 数组的最后一位） 如果没有缓存，则缓存该实例，若 keys 的长度大于 max （缓存长度超过上限），则移除 keys[0] 缓存 下面我们来自己实现一个 LRU 算法吧⛽️⛽️⛽️ 三、leetcode：LRU 缓存机制 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和写入数据 put 。 获取数据 get(key) - 如果密钥 ( key ) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1 。 写入数据 put(key, value) - 如果密钥不存在，则写入数据。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据，从而为新数据留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 前面已经介绍过了 keep-alive 中LRU实现源码，现在来看这道题是不是很简单&#x1F60A;&#x1F60A;&#x1F60A;，可以尝试自己解答一下⛽️，然后思考一下有没有什么继续优化的！欢迎提供更多的解法 function LRU(max) { this.max = max; this.cache = new Map(); } LRU.prototype = { get(key) { const { cache } = this, value = cache.get(key); if (!value) return; cache.delete(key); cache.set(key, value); return value; }, add(key, value) { const { cache } = this; if (cache.size > this.max - 1) { const keys = cache.keys().next().value; cache.delete(keys); } cache.set(key, value); } }; const lru = new LRU(4); lru.add(1, 1); lru.add(2, 2); lru.add(3, 3); lru.add(4, 4); lru.get(2); lru.get(2); lru.get(2); lru.add(5, 5); console.log(lru.cache); 答案已提交到 #7 "},"Algorithm/链表原来如此简单.html":{"url":"Algorithm/链表原来如此简单.html","title":"链表原来如此简单","keywords":"","body":"链表原来如此简单 引言 链表相对于数组来说，要复杂的多，首先，==链表不需要连续的内存空间，它是由一组零散的内存块透过指针连接而成==，所以，每一个块中必须包含当前节点内容以及后继指针。最常见的链表类型有单链表、双链表以及循环链表。 学习链表最重要的是 多画图多练习 ，没有捷径可循，在遇到链表问题时，瓶子君总结了一下，可以按照以下五步骤： 确定解题的数据结构：单链表、双链表或循环链表等 确定解题思路：如何解决问题 画图实现：画图可以帮助我们发现思维中的漏洞（一些思路不周的情况） 确定边界条件：思考解题中是否有边界问题以及如何解决 代码实现：解题完成✅ 本文会给常用链表（单链表、双链表以及循环链表）的基本操作已经代码实现，并给出实现思路，这些都是链表解题的基石，请务必掌握！⛽️⛽️⛽️ 最后附赠一道 leetcode 题目，并按照链表解题五步骤给出答案！ 下面开始本节的学习吧！！！&#x1F447;&#x1F447;&#x1F447; 一、单链表 单链表结构： function List () { // 节点 let Node = function (element) { this.element = element this.next = null } // 初始头节点为 null let head = null // 链表长度 let length = 0 // 操作 this.getList = function() {return head} this.search = function(list, element) {} this.append = function(element) {} this.insert = function(position, element) {} this.remove = function(element){} this.isEmpty = function(){} this.size = function(){} } 1. 追加节点： 确定解题的数据结构：单链表 确定解题思路： 初始化一个节点（待追加节点），遍历到链尾，在尾节点后插入该节点 画图实现： 确定边界条件： 当链表为 null ，直接将 head 指向待插入节点，不需要遍历 代码实现： function append (element) { let node = new Node(element), p = head if (!head){ head = node } else { while (p.next) { p = p.next } p.next = node } length += 1 } // 测试 let list = new List() for(let i = 0; i 解题完成✅ 2. 查找： 确定解题的数据结构：单链表 确定解题思路： 遍历单链表，判断节点值是否等于待查找值，相等则返回 true ，否则继续遍历下一个节点，直到遍历完整个链表还未找到，则返回 false 画图实现： 很简单，读者可以尝试画一下 确定边界条件： 当链表为 null ，可直接返回 false 代码实现： // 判断链表中是否存在某节点 function search(element) { let p = head if (!p) return false while(p) { if (p.element === element) return true p = p.next } return false } // 测试 list.search(4) // true list.search(11) // false 解题完成✅ 3. 在 position 位置插入： 确定解题的数据结构：单链表 确定解题思路： 初始化一个节点（待插入节点 node ），遍历到 position 前一个位置节点，在该节点后插入 node 画图实现： 确定边界条件： 当 position 为 0 时，直接将插入节点 node.next 指向 head ， head 指向 node 即可，不需要遍历 当待插入位置 position 或超出链表长度 position > length ，都是有问题的，不可插入，此时直接返回 null ，插入失败 代码实现： // 插入 position 的后继节点 function insert (position, element) { // 创建插入节点 let node = new createNode(element) //边界条件 if (position >= 0 && position 解题完成✅ 4. 删除： 确定解题的数据结构：单链表 确定解题思路： 遍历单链表，找到待删除节点，删除 画图实现： 确定边界条件： 当链表为 null ，直接返回 代码实现： // 删除值为 element 节点 function remove (element) { let p = head, prev = head if(!head) return while(p) { if(p.element === element) { p = p.next prev.next = p } else { prev = p p = p.next } } } 解题完成✅ 5. 复杂度分析： 查找：从头节点开始查找，时间复杂度为 O(n) 插入或删除：在某一节点后插入或删除一个节点（后继节点）的时间复杂度为 O(1) 链表五步骤是不是很好用&#x1F60A;，下面看一下双链表&#x1F447; 二、双链表 顾名思义，单链表只有一个方向，从头节点到尾节点，那么双链表就有两个方向，从尾节点到头节点： function DoublyLinkedList() { let Node = function(element) { this.element = element // 前驱指针 this.prev = null // 后继指针 this.next = null } // 初始头节点为 null let head = null // 新增尾节点 let tail = null // 链表长度 let length = 0 // 操作 this.search = function(element) {} this.insert = function(position, element) {} this.removeAt = function(position){} this.isEmpty = function(){ return length === 0 } this.size = function(){ return length } } 1. 在 position 位置插入节点： 确定解题的数据结构： 双链表 确定解题思路： 初始化一个节点（待插入节点 node ），遍历链表到 position 前一个位置节点，在该节点位置后插入 node 画图实现： 确定边界条件： 当待插入位置 position 或超出链表长度 position > length ，都是有问题的，不可插入，此时直接返回 null ，插入失败 代码实现： // 插入 position 的后继节点 function insert (position, element) { // 创建插入节点 let node = new Node(element) //边界条件 if (position >= 0 && position 解题完成✅ 2. 删除： 确定解题的数据结构： 双链表 确定解题思路： 遍历双链表，找到待删除节点，删除 画图实现： 确定边界条件： 当链表为 null ，直接返回 代码实现： // 删除 position 位置的节点 function removeAt (position) { if (position >= 0 && position 0) { let prev = head, curr = head, index = 0 if(position === 0) { // 移除头节点 if(length === 1) { // 仅有一个节点 head = null tail = null } else { head = head.next head.prev = null } } else if(position === length-1) { // 移除尾节点 curr = tial tail = curr.prev tail.next = null } else { while(index 解题完成✅ 3. 查找： 双链表的查找和单链表类似，都是遍历链表，找到返回 true，找不到返回 false 。 4. 复杂度分析： 查找：查找前驱节点或后继节点时间复杂度为 O(1)，其它节点仍为 O(n) 插入或删除：插入或删除前驱节点或后继节点的时间复杂度都为 O(1) 三、循环单链表 循环单链表是一种特殊的单链表，它和单链表的唯一区别是：单链表的尾节点指向的是 NULL，而循环单链表的尾节点指向的是头节点，这就形成了一个首尾相连的环： 既然有循环单链表，当然也有循环双链表，循环双链表和双链表不同的是： 循环双链表的 tail.next（ tail 的后继指针） 为 null ，循环双链表的 tail.next 为 head 循环双链表的 head.prev（ head 的前驱指针） 为 null ，循环双链表的 head.prev 为 tail 这里以循环单列表为例 function CircularLinkedList() { let Node = function(element) { this.element = element // 后继指针 this.next = null } // 初始头节点为 null let head = null // 链表长度 let length = 0 // 操作 this.search = function(element) {} this.insert = function(positon, element) {} this.removeAt = function(position){} this.isEmpty = function(){ return length === 0 } this.size = function(){ return length } } 1. 在 positon 后插入： 确定解题的数据结构： 循环单链表 确定解题思路： 初始化一个节点（待插入节点 node ），遍历到 position 前一个位置节点，在该节点后插入 node 画图实现： 确定边界条件： 当 position 为 0 时，需要遍历到尾节点，然后在尾节点后插入节点 ， 并将 head 指向 当待插入位置 position 或超出链表长度 position > length ，都是有问题的，不可插入，此时直接返回 null ，插入失败 代码实现： // 插入 position 的后继节点 function insert (position, element) { // 创建插入节点 let node = new createNode(element) if (position >= 0 && position 解题完成✅ 2. 查找： 和单链表类似，唯一不同的是：循环单链表的循环结束条件为 index++ // 判断链表中是否存在某节点 function search(element) { if (!head) return false let p = head, index = 0 // 和单链表的不同所在 while(index++ 解题完成✅ 3. 删除： 和单链表类似，唯一不同的是：循环单链表的循环结束条件为 index++ // 删除值为 element 节点 function remove (element) { let p = head, prev = head, index = 0 // 空链表 if(!head || ) return // 仅有一个节点且element一致 if(length === 1 && head.element === element){ head = null length-- return } while(index++ 解题完成✅ 4. 复杂度分析 查找：循环链表从任一节点开始查找目标节点，时间复杂度为 O(n) 插入或删除：它和单链表一样，后继节点插入及删除的时间复杂度为 O(1) 四、leetcode21：合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 欢迎将答案提交到 #11 "},"Vue/":{"url":"Vue/","title":"Vue知识点","keywords":"","body":"Vue知识点 "},"Vue/Proxy 基本使用与defineProperty.html":{"url":"Vue/Proxy 基本使用与defineProperty.html","title":"Proxy 基本使用与defineProperty","keywords":"","body":"Proxy 基本使用与defineProperty "},"Vue/面试题串讲_vue.html":{"url":"Vue/面试题串讲_vue.html","title":"面试题串讲_vue","keywords":"","body":"面试题串讲_vue "},"React/":{"url":"React/","title":"React知识点","keywords":"","body":"React知识点 "},"React/setState解析.html":{"url":"React/setState解析.html","title":"setState解析","keywords":"","body":"setState解析 "},"React/Fetch异步中止.html":{"url":"React/Fetch异步中止.html","title":"Fetch异步中止","keywords":"","body":"Fetch异步中止 "},"React/面试题串讲_react.html":{"url":"React/面试题串讲_react.html","title":"面试题串讲_react","keywords":"","body":"面试题串讲_react "},"ReactNative/":{"url":"ReactNative/","title":"ReactNative","keywords":"","body":"ReactNative "},"ReactNative/RN分包机制.html":{"url":"ReactNative/RN分包机制.html","title":"RN分包机制","keywords":"","body":"React native拆包之 原生加载多bundle 为什么要拆包？ bundle文件过大： 一个Helloworld的App，如果使用0.53RN 官方命令react-native bundle打包出来的JSBundle文件大小大约为530KB，RN依赖模块本身占了99.9%。 页面加载慢： 如果使用热更新，从网络获取整个包的下载时间很长，每次进入RN页面都需要执行RN基础模块的定义。 如果只是一个单独的新APP，纯RN的，或者只有一两个业务使用，这点大小算不了什么。 但是对于很多业务的公司项目，如果每个业务的JSBundle都需要这么大的一个RN框架，那将是没必要的。 Facebook官方有没有解决方案呢？ Facebook的打包工具是metro, metro自带unbundle命令，不过，打包结果不符合预期； Android端是将每一个模块输出到单个文件并以模块ID命名；IOS端是将模块以流形式打到一个文件中； 方案 调研的方案可以分三类： 1.手动拆分&合并后再加载 使用RN打包工具打包，手动将文件分开分成基础包A.js, 业务包B.js;然后在APP加载该页面的时候将A,B两个文件合并再执行； 优点：成本低，不需要改打包工具； 缺点：性能没有提升，不能优化执行时间，反而会增加； 2.动态更新 可以从编译产物看到require(moduleID)；这个方案的思路是：编写一个空的React容器组件，利用DeviceEventEmitter监听一个Native事件，在需要加载页面时，Native下载将模块保存下来，以对应模块ID命名，然后通过DeviceEventEmitter对应模块的id发给React来调用require(msg.id) ReactNative 打包命令说明 使用 react-native bundle --help 来查看打包的具体参数 react-native bundle [参数] 构建 js 离线包 Options: -h, --help 输出如何使用的信息 --entry-file RN入口文件的路径, 绝对路径或相对路径 --platform [string] ios 或 andorid --transformer [string] Specify a custom transformer to be used --dev [boolean] 如果为false, 警告会不显示并且打出的包的大小会变小 --prepack 当通过时, 打包输出将使用Prepack格式化 --bridge-config [string] 使用Prepack的一个json格式的文件__fbBatchedBridgeConfig 例如: ./bridgeconfig.json --bundle-output 打包后的文件输出目录, 例: /tmp/groups.bundle --bundle-encoding [string] 打离线包的格式 可参考链接https://nodejs.org/api/buffer.html#buffer_buffer. --sourcemap-output [string] 生成Source Map，但0.14之后不再自动生成source map，需要手动指定这个参数。例: /tmp/groups.map --assets-dest [string] 打包时图片资源的存储路径 --verbose 显示打包过程 --reset-cache 移除缓存文件 --config [string] 命令行的配置文件路径 ReactNative 打离线包流程 (举例iOS) 执行打包命令 react-native bundle --entry-file index.ios.js --bundle-output ./ios/bundle/index.ios.jsbundle --platform ios --assets-dest ./ios/bundle --dev false Unable to parse cache file. Will clear and continue. [2017-1-3 16:58:56] Initializing Packager [2017-1-3 16:58:56] Building in-memory fs for JavaScript [2017-1-3 16:58:56] Building in-memory fs for JavaScript (74ms) [2017-1-3 16:58:57] Building Haste Map [2017-1-3 16:58:57] Building Haste Map (392ms) [2017-1-3 16:58:57] Initializing Packager (498ms) [2017-1-3 16:58:57] Transforming files [2017-1-3 16:58:57] Transforming files (436ms) bundle: start bundle: finish bundle: Writing bundle output to: ./ios/bundle/index.ios.jsbundle bundle: Copying 5 asset files bundle: Done writing bundle output bundle: Done copying assets 生成的jsbundle基本分成3个部分： 头部：全局定义，主要是define，require等全局模块的定义 中部：模块定义，RN框架和业务的各个模块定义 尾部：引擎初始化和入口函数执行 __d是RN自定义的define，d后面的数字是模块的id，是在RN打包过程中，解析依赖关系，自增长生成。d结构： // 一个基本的结构。注：v0.55，之前的版本define可能不同 __d( function(e,r,a,i,l){ var n=r(l[0]); babelHelpers.interopRequireDefault(n); r(l[1]) }, 11,//模块 id [12,17] ); // define __d( function(global, ...) { (module transformed code) }, moduleId, dependencyMap?, moduleName? ); 参考 (RN) 拆(分)包实践-iOS react-native实现不重启App的情况下更新分包 React native拆包之 原生加载多bundle（iOS&Android） React native拆包的正确姿势——基于metro bundle 袁 聪 - 全民K歌React Native实践与优化 同app下多个react-native jsBundle的解决方案 React Native Application和Activity源码分析 "}}